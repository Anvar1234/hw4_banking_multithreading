### ТЗ
Задача на многопоточность: из тестового задания на собеседование:

Создать 4 банковских аккаунта. Каждый аккаунт должен иметь поля: 1) UUID, 2) человекочитаемый идентификатор, который создается из файла который мы парсим parsingfile.txt конкантенацией имен и фамилий и последних цифр года рождения в виде «ИванИванов98», 3) поле money.

На каждом аккаунте изначально по 10000 рублей. Есть методы deposit() и withdraw(), который соответственно кладут и снимают деньги на аккаунт. Каждая операция логируется в общий файл с указанием владельца аккаунта, операции, суммы операции и текущего остатка на аккаунте. Приложение должно корректно обрабатывать и логировать ошибки.

В приложении запускается несколько (не менее двух) независимых потоков. Потоки должны просыпаться каждые 1000-2000 мс. Время на которое засыпает поток выбирается случайно при каждом исполнении.
Потоки должны выполнять перевод средств с одного счета на другой. Сумма списания или зачисления определяется случайным образом. Поле money не должно становиться отрицательным, сумма money на всех счетах не должна меняться.
Решение должно быть масштабируемым по количеству счетов и потоков и обеспечивать возможность одновременного (параллельного) перевода средств со счета a1 на счет a2 и со счета a3 на счет а4 в разных потоках.
Результаты всех транзакций должны записываться в лог.
После 30 выполненных транзакций приложение должно завершиться с проверкой, что сумма на всех счетах всё так же осталась 40000.

### Основные моменты:
#### Примечание: я не делал валидацию ввода, проверку выхода за пределы количества счетов и тп. Основное внимание было приковано на многопоточность и логирование.
1. В классе Account добавил дополнительное поле класса countAcconts, чтобы можно было отслеживать общее кол-во аккаунтов. Также добавил поле экземпляров класса simpleID, чтобы по этому простому идентификатору можно было осуществлять переводы.
2. По пакетам: 
* creator содержит класс для создания списка аккаунтов путем парсинга файла. 
* model - классы-шаблоны аккаунтов и исключения. 
* runner - класс, в котором компонуем классы между собой. 
* service - основная логика. 
* util - логгер.  
3. По логгеру - он настраивается через файл свойств (log.properties), что позволяет перенастраивать его в случае необходимости. 
Коротко: результаты операций deposit() и withdraw() логгируются в консоль (а также все остальные сообщения), а результаты транзакций в общем и ошибки - в файл.
Сейчас уровень корневого логгера установлен как FINE (как и у консольного логгера), поэтому на консоль выводятся все сообщения,
которые логгируются в приложении. Но мы можем изменить уровень корневого логгера на INFO, тогда в консоль будет выводиться то же, 
что и в файл. В файл же пишутся только с уровня INFO. Такой настройкой мы можем регулировать, чтобы если это не нужно, 
то лишнее логгирование не происходило. А если же какие-то проблемы возникают (теоретически) в методах withdraw() и deposit(), 
то мы, установив уровень корневого логирования а также файлового или консольного логгера на FINE, сможем видеть что происходит в них.
4. В начале работы приложения выводится список всех аккаунтов. Далее мы выбираем между сколькими парами счетов (по сути - 
со сколькими транзакциями) мы будем работать. Далее выбираем количество циклов транзакций (по условию их 30, но оставил для 
регулировки количества). Далее выбираем количество потоков, выполняющих эти транзакции. 
Дальше вводим то самое simpleID счета, с которого переводим, затем того - куда переводим. Дальше стартует сама логика переводов.
5. По условиям масштабируемости приложения: при добавлении новых записей в файл parsingfile.txt приложение работает как нужно (на данный момент добавлена одна новая запись). 
Можем изменять параметры работы: количество транзакций, количество циклов всех транзакций, количество потоков.

### ВОПРОСЫ!
1. Не до конца понимаю, когда использовать синхронайзд, когда ReentrantLock, когда wait и notify. 

2. Во внутренних методах создавать потоки или в главном? Когда нужно создавать потоки?

3. Какие из методов (например у меня) нужно синхронизировать, а какие нет смысла?

4. Когда нужно создавать класс-поток? Так же не совсем ясно, когда и где мы должны переопределить метод run. Нет, ясно, что когда хотим создать поток (ext Thread или impl Runnable), но когда именно это нужно. А когда можно просто использовать в сторонних потоках какой-то метод класса? Ну то есть мы же можем создать какой-то класс-поток (реализовав раннабле напр), там переопределить метод run и дальше вызывать потоки. А можем не создавать класс-поток и уже где-то в мейн например вызвать метод какого-то обычного класса.

5. Мне нужно синхронизировать только метод doTransfer или же и (или только) методы класса Account?

6. Зачем нужен Reentrantlock, если то же самое мы можем сделать в цикле и с помощью join или awaitTermination?

7. Усыплять потоки нужно в методе run, или в методах withdraw и deposit? 



